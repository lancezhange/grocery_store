(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{472:function(t,a,s){"use strict";s.r(a);var r=s(17),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"c-知识点-ignore-ture"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c-知识点-ignore-ture"}},[t._v("#")]),t._v(" C++ 知识点 {ignore=ture}")]),t._v(" "),s("p",[t._v("[TOC]")]),t._v(" "),s("blockquote",[s("p",[t._v("如果将编程语言比作武功秘籍，C++无异于《九阴真经》。《九阴真经》威力强大、博大精深，经中所载内功、轻功、拳、掌、腿、刀法、剑法、杖法、鞭法、指爪、点穴密技、疗伤法门、闭气神功、移魂大法等等，无所不包，C++亦如是。")])]),t._v(" "),s("h2",{attrs:{id:"c-语法关键"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c-语法关键"}},[t._v("#")]),t._v(" C++ 语法关键")]),t._v(" "),s("h3",{attrs:{id:"函数声明和对象定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数声明和对象定义"}},[t._v("#")]),t._v(" 函数声明和对象定义")]),t._v(" "),s("p",[t._v("对象定义写成空的初始化列表时，会被解析成一个函数声明。")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("\n//这是一个函数声明\n//不是一个对象定义\nstring foo();\n\n\n//函数声明\nstring foo(void);\n\n\n//对象定义几种方法\nstring foo;\nstring foo{ };//c++11\nstring *foo = new string;\nstring *foo = new string();\nstring *foo = new string{ };//c++11\n")])])]),s("h3",{attrs:{id:"类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类型"}},[t._v("#")]),t._v(" 类型")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("枚举类型\n占用 4 个字节")])]),t._v(" "),s("li",[s("p",[t._v("柔性数组")]),t._v(" "),s("ul",[s("li",[t._v("例如"),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("A")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\nInt a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" data"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 必须是结构体的最后一个元素")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),t._v("柔性数组其实只是一个标识占位符，并不占结构体的空间")])])])]),t._v(" "),s("h3",{attrs:{id:"指针"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#指针"}},[t._v("#")]),t._v(" 指针")]),t._v(" "),s("p",[t._v("指针")]),t._v(" "),s("ul",[s("li",[t._v("指针数组： 每个元素都是指针 "),s("code",[t._v("char \\*p[10];")])]),t._v(" "),s("li",[t._v("数组指针： 指向数组的指针 "),s("code",[t._v("int (\\*p)[10]")]),t._v("; 对二维数组，可以用数组指针指向一行，然后 p++ 就指向下一行（注意数组指针的步长为列数），数组指针因此也被称为行指针")]),t._v(" "),s("li",[t._v("声明一个类的指针数组时，并不会调用该类的构造函数")])]),t._v(" "),s("h4",{attrs:{id:"智能指针"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#智能指针"}},[t._v("#")]),t._v(" 智能指针")]),t._v(" "),s("p",[t._v("std::auto_ptr")]),t._v(" "),s("h4",{attrs:{id:"共享指针"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#共享指针"}},[t._v("#")]),t._v(" 共享指针")]),t._v(" "),s("p",[t._v("std::shared_ptr")]),t._v(" "),s("h3",{attrs:{id:"友元"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#友元"}},[t._v("#")]),t._v(" 友元")]),t._v(" "),s("p",[t._v("友元函数本身不是类的成员函数")]),t._v(" "),s("h3",{attrs:{id:"多态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[t._v("#")]),t._v(" 多态")]),t._v(" "),s("p",[t._v("函数重载和模板属于编译时多态")]),t._v(" "),s("p",[t._v("如果不是虚函数，则用子类初始化的基类指针调用的是基类的，对析构函数也是如此，因此，为了使子类正常析构，子类的析构函数通常被声明为虚函数。")]),t._v(" "),s("h3",{attrs:{id:"联合体"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#联合体"}},[t._v("#")]),t._v(" 联合体")]),t._v(" "),s("p",[t._v("联合体的占用空间取其包含元素的最大占用空间")]),t._v(" "),s("h3",{attrs:{id:"编译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译"}},[t._v("#")]),t._v(" 编译")]),t._v(" "),s("p",[s("code",[t._v("g++ -o test test.cpp")])]),t._v(" "),s("h3",{attrs:{id:"static-关键字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#static-关键字"}},[t._v("#")]),t._v(" static 关键字")]),t._v(" "),s("p",[t._v("static 关键字的作用：隐藏，持久化，初始化为 0")]),t._v(" "),s("ul",[s("li",[t._v("静态全局变量\n"),s("ul",[s("li",[t._v("作用域仅限于当前源文件，且只初始化一次")])])]),t._v(" "),s("li",[t._v("静态局部变量")]),t._v(" "),s("li",[t._v("静态函数\n"),s("ul",[s("li",[t._v("普通函数在每次被调用时均有一份拷贝，而静态函数在内存中只拷贝一份，因此比较节约内存")]),t._v(" "),s("li",[t._v("静态函数只在声明它的源文件中可见，因此其他文件中可以定义相同名字的函数，不会发生冲突")])])])]),t._v(" "),s("h3",{attrs:{id:"输入输出流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#输入输出流"}},[t._v("#")]),t._v(" 输入输出流")]),t._v(" "),s("ul",[s("li",[t._v("stdio.h 与 cstdio 的区别：前者是 C 的标准库，后者是 C++中对前者的封装；其他如 stdlib.h 与 cstdlib 同理。")])]),t._v(" "),s("h3",{attrs:{id:"inline-内联函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#inline-内联函数"}},[t._v("#")]),t._v(" inline 内联函数")]),t._v(" "),s("p",[t._v("内联类似于宏定义，在调用处直接展开被调函数，以此来代替函数调用，在消除宏定义的缺点的同时又保留了其优点。内联有以下几个主要特点")]),t._v(" "),s("ol",[s("li",[t._v("内联可以发生在任何时机，包括编译期、链接期、运行时等；")]),t._v(" "),s("li",[t._v("有些编译器即使不加 "),s("code",[t._v("inline")]),t._v(" 关键字，也可能会对短小的函数做内联优化")]),t._v(" "),s("li",[t._v("编译器很无情，即使你加了 inline，它也可能拒绝你的 inline")]),t._v(" "),s("li",[t._v("不合理的 inline 会导致代码臃肿")])]),t._v(" "),s("h3",{attrs:{id:"模板元编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模板元编程"}},[t._v("#")]),t._v(" 模板元编程")]),t._v(" "),s("h3",{attrs:{id:"魔鬼在细节之中"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#魔鬼在细节之中"}},[t._v("#")]),t._v(" 魔鬼在细节之中")]),t._v(" "),s("p",[t._v("一些容易混淆和忽略的点")]),t._v(" "),s("ul",[s("li",[t._v("赋值表达式的返回值即所赋值本身")])]),t._v(" "),s("p",[t._v("静态对象初始化顺序\n在同一个编译单元中，静态对象的初始化次序与其定义顺序保持一致。对于作用域为多个编译单元的静态对象，不能保证其初始化次序。")]),t._v(" "),s("p",[t._v("如果我们需要指定依赖关系，比如 y 依赖 x 进行初始化，可以利用这样一个特性来实现：函数内部的静态对象在函数第一次调用时初始化，且只被初始化一次。使用该方法，访问静态对象的唯一途径就是调用该函数")]),t._v(" "),s("h2",{attrs:{id:"stl"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stl"}},[t._v("#")]),t._v(" STL")]),t._v(" "),s("ul",[s("li",[t._v("STL string\n"),s("ul",[s("li",[t._v('构造 string a("this is a string");')]),t._v(" "),s("li",[t._v("size(), empty()")])])]),t._v(" "),s("li",[t._v("string stream\n"),s("ul",[s("li",[t._v("istringstream")]),t._v(" "),s("li",[t._v("ostringstream")]),t._v(" "),s("li",[t._v("string 化： .str()")])])])]),t._v(" "),s("ul",[s("li",[t._v("对齐\n"),s("ul",[s("li",[s("code",[t._v("#pragma pack(4)")])])])])]),t._v(" "),s("h2",{attrs:{id:"并行编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并行编程"}},[t._v("#")]),t._v(" 并行编程")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.gitbook.com/book/chenxiaowei/cpp_concurrency_in_action/details",target:"_blank",rel:"noopener noreferrer"}},[t._v("gitbook: C++ 并发编程"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"常用库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常用库"}},[t._v("#")]),t._v(" 常用库")]),t._v(" "),s("h3",{attrs:{id:"algorithm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#algorithm"}},[t._v("#")]),t._v(" algorithm")]),t._v(" "),s("h3",{attrs:{id:"cstring-和-string"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cstring-和-string"}},[t._v("#")]),t._v(" cstring 和 string")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://github.com/p-ranav/argparse",target:"_blank",rel:"noopener noreferrer"}},[t._v("argparse-参数解析"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:""}},[t._v("getopt:命令行参数解析")])])]),t._v(" "),s("h2",{attrs:{id:"参考资料"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/fffaraz/awesome-cpp",target:"_blank",rel:"noopener noreferrer"}},[t._v("Awesome Cpp"),s("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=e.exports}}]);