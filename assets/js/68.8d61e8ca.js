(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{468:function(t,a,s){"use strict";s.r(a);var r=s(17),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"并发并行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发并行"}},[t._v("#")]),t._v(" 并发并行")]),t._v(" "),s("h2",{attrs:{id:"多线程和多进程编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多线程和多进程编程"}},[t._v("#")]),t._v(" 多线程和多进程编程")]),t._v(" "),s("h3",{attrs:{id:"死锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[t._v("#")]),t._v(" 死锁")]),t._v(" "),s("p",[t._v("所谓死锁，指的是多个进程竞争资源，导致互相等待")]),t._v(" "),s("p",[t._v("死锁的四个必要条件")]),t._v(" "),s("ol",[s("li",[t._v("互斥： 资源不能被共享，只能有一个进程使用")]),t._v(" "),s("li",[t._v("请求与保持： 已经得到资源的进程可以再次申请新的资源")]),t._v(" "),s("li",[t._v("非剥夺条件： 已经分配的资源不能从相应的进程中被强制剥夺")]),t._v(" "),s("li",[t._v("循环等待： 系统中若干进程组成环路，该环路中的每个进程都在等待相邻进程正占用的资源")])]),t._v(" "),s("p",[t._v("避免死锁的"),s("strong",[t._v("银行家算法")])])])}),[],!1,null,null,null);a.default=e.exports}}]);